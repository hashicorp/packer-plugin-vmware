// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package common

import (
	"errors"
	"fmt"
	"html/template"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"github.com/hashicorp/packer-plugin-sdk/multistep"
)

// VMware Workstation

// netmapTemplate is a template for the network mapper configuration file.
// This file is used to map network devices to their respective network names.
// This template is used to generate the file if the default file does not
// exist on the system.
const netmapTemplate = `
# This file is automatically generated.
# Hand-editing this file is not recommended.
network0.name = "Bridged"
network0.device = "vmnet0"
network1.name = "HostOnly"
network1.device = "vmnet1"
{{- range . }}
{{- if gt .Index 1 }}
{{- if lt .Index 8 }}
network{{ .Index }}.name = "VMNet{{ .Index }}"
network{{ .Index }}.device = "vmnet{{ .Index }}"
{{- else if eq .Index 8 }}
network8.name = "NAT"
network8.device = "vmnet8"
{{- else }}
network{{ .Index }}.name = "VMNet{{ .Index }}"
network{{ .Index }}.device = "vmnet{{ .Index }}"
{{- end }}
{{- end }}
{{- end }}
`

// NetmapConfig is a struct that represents a network mapper configuration.
type NetmapConfig struct {
	Index  int
	Name   string
	Device string
}

// WorkstationDriver is a driver for VMware Workstation.
type WorkstationDriver struct {
	VmwareDriver

	AppPath          string
	VdiskManagerPath string
	VmrunPath        string

	SSHConfig *SSHConfig
}

// NewWorkstationDriver creates a new WorkstationDriver instance for managing VMware Workstation virtual machines.
func NewWorkstationDriver(config *SSHConfig) Driver {
	return &WorkstationDriver{
		SSHConfig: config,
	}
}

// GetVmwareDriver returns the underlying VmwareDriver instance.
func (d *WorkstationDriver) GetVmwareDriver() VmwareDriver {
	return d.VmwareDriver
}

// Clone creates a copy of the source virtual machine at the destination path.
func (d *WorkstationDriver) Clone(dst, src string, linked bool, snapshot string) error {

	var cloneType string
	if linked {
		cloneType = cloneTypeLinked
	} else {
		cloneType = cloneTypeFull
	}

	args := []string{"-T", "ws", "clone", src, dst, cloneType}
	if snapshot != "" {
		args = append(args, "-snapshot", snapshot)
	}
	cmd := exec.Command(d.VmrunPath, args...)
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

// CompactDisk defragments and compacts the virtual disk to reclaim unused space.
func (d *WorkstationDriver) CompactDisk(diskPath string) error {
	defragCmd := exec.Command(d.VdiskManagerPath, "-d", diskPath)
	if _, _, err := runAndLog(defragCmd); err != nil {
		return err
	}

	shrinkCmd := exec.Command(d.VdiskManagerPath, "-k", diskPath)
	if _, _, err := runAndLog(shrinkCmd); err != nil {
		return err
	}

	return nil
}

// CreateDisk creates a new virtual disk with the specified parameters.
func (d *WorkstationDriver) CreateDisk(output string, size string, adapterType string, typeId string) error {
	cmd := exec.Command(d.VdiskManagerPath, "-c", "-s", size, "-a", adapterType, "-t", typeId, output)
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

// CreateSnapshot creates a named snapshot of the virtual machine.
func (d *WorkstationDriver) CreateSnapshot(vmxPath string, snapshotName string) error {
	cmd := exec.Command(d.VmrunPath, "-T", "ws", "snapshot", vmxPath, snapshotName)
	_, _, err := runAndLog(cmd)
	return err
}

// IsRunning checks if the virtual machine is currently powered on.
func (d *WorkstationDriver) IsRunning(vmxPath string) (bool, error) {
	vmxPath, err := filepath.Abs(vmxPath)
	if err != nil {
		return false, err
	}

	cmd := exec.Command(d.VmrunPath, "-T", "ws", "list")
	stdout, _, err := runAndLog(cmd)
	if err != nil {
		return false, err
	}

	for _, line := range strings.Split(stdout, "\n") {
		if line == vmxPath {
			return true, nil
		}
	}

	return false, nil
}

// CommHost returns the host address for SSH communication with the virtual machine.
func (d *WorkstationDriver) CommHost(state multistep.StateBag) (string, error) {
	return CommHost(d.SSHConfig)(state)
}

// Start powers on the virtual machine in headless or GUI mode.
func (d *WorkstationDriver) Start(vmxPath string, headless bool) error {
	guiArgument := guiArgumentNoGUI
	if !headless {
		guiArgument = guiArgumentGUI
	}

	cmd := exec.Command(d.VmrunPath, "-T", "ws", "start", vmxPath, guiArgument)
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

// Stop forcibly powers off the virtual machine.
func (d *WorkstationDriver) Stop(vmxPath string) error {
	cmd := exec.Command(d.VmrunPath, "-T", "ws", "stop", vmxPath, "hard")
	if _, _, err := runAndLog(cmd); err != nil {
		// Check if the virtual machine is running. If not, it is stopped.
		running, runningErr := d.IsRunning(vmxPath)
		if runningErr == nil && !running {
			return nil
		}
		return err
	}

	return nil
}

// SuppressMessages configures the virtual machine to suppress dialog messages.
func (d *WorkstationDriver) SuppressMessages(vmxPath string) error {
	return nil
}

// Verify validates the VMware Workstation installation and configuration.
func (d *WorkstationDriver) Verify() error {
	log.Printf("[INFO] Searching for %s...", workstationProductName)

	if err := workstationVerifyVersion(workstationMinVersionObj.String()); err != nil {
		return fmt.Errorf("version verification failed: %s", err)
	}

	components := map[string]*string{
		appVmware:       &d.AppPath,
		appVmrun:        &d.VmrunPath,
		appVdiskManager: &d.VdiskManagerPath,
	}

	for name, path := range components {
		if *path == "" {
			var finderFunc func() (string, error)
			switch name {
			case appVmware:
				finderFunc = workstationFindVMware
			case appVmrun:
				finderFunc = workstationFindVmrun
			case appVdiskManager:
				finderFunc = workstationFindVdiskManager
			default:
				return fmt.Errorf("unknown component: %s", name)
			}

			if foundPath, err := finderFunc(); err != nil {
				return fmt.Errorf("%s not found: %s", name, err)
			} else {
				*path = foundPath
				log.Printf("[INFO] - %s found at: %s", name, *path)
			}
		}
	}

	if err := workstationCheckLicense(); err != nil {
		return err
	}

	// Assigning the path callbacks to VmwareDriver
	d.DhcpLeasesPath = func(device string) string {
		return workstationDhcpLeasesPath(device)
	}

	d.DhcpConfPath = func(device string) string {
		return workstationDhcpConfPath(device)
	}

	d.VmnetnatConfPath = func(device string) string {
		return workstationNatConfPath(device)
	}

	d.NetworkMapper = func() (NetworkNameMapper, error) {
		// Check if the network mapper configuration file exists.
		mapper, err := checkNetmapConfExists()

		if err == nil {
			return mapper, nil
		}

		// For non-Windows, if neither the default nor alternate configuration
		// paths exist, return an error.
		if err != nil && runtime.GOOS != osWindows {
			return nil, err
		}

		if !errors.Is(err, os.ErrNotExist) {
			return nil, err
		}

		// For Windows, safely generate the network mapper configuration file
		// in the default path.
		pathNetmap, err := generateNetmapConfig()
		if err != nil {
			log.Fatalf("error generating the absent network configuration file: %v", err)
			return nil, err
		}

		// If the file exists, attempt to read the newly generated network
		// mapper configuration file.
		return ReadNetmapConfig(pathNetmap)
	}
	return nil
}

// ToolsIsoPath returns the path to the VMware Tools ISO for the specified OS flavor.
func (d *WorkstationDriver) ToolsIsoPath(flavor string) string {
	return workstationToolsIsoPath(flavor)
}

// ToolsInstall installs VMware Tools on the guest operating system.
func (d *WorkstationDriver) ToolsInstall() error {
	return nil
}

// checkNetmapConfExists checks if the network mapper configuration file exists.
// If not, if attempts to generate the file using generateNetmapConfig.
func checkNetmapConfExists() (NetworkNameMapper, error) {
	pathNetmap := workstationNetmapConfPath()

	// Check if the default network mapper configuration file exists.
	_, err := os.Stat(pathNetmap)

	if err == nil {
		// If the default network mapper configuration file exists, read the configuration.
		log.Printf("[INFO] Located the network mapper configuration file: %s", pathNetmap)
		return ReadNetmapConfig(pathNetmap)
	}

	if !os.IsNotExist(err) {
		return nil, fmt.Errorf("error determining network mappings from files %w", err)
	}

	log.Printf("[INFO] A network mapper configuration file does not exist in the default path: %s", pathNetmap)

	// The file does not exist, check the alternate configuration path.
	libpath, _ := workstationInstallationPath()
	pathNetworking := filepath.Join(libpath, "networking")
	log.Printf("[INFO] Checking alternate path for network mapper configuration file: %s", pathNetworking)
	_, err = os.Stat(pathNetworking)

	// If there is an error, wrap return it.
	// The caller can check if it is a ErrNotExist and act accordingly.
	if err != nil {
		return nil, fmt.Errorf("error determining network mappings from files %w", err)
	}

	// Alternate networking configuration path exists. Using this path.
	log.Printf("[INFO] Located the network mapper configuration file: %s", pathNetworking)
	fd, err := os.Open(pathNetworking)
	if err != nil {
		return nil, err
	}

	defer fd.Close()

	// Pass the handle to the networking configuration parser.
	return ReadNetworkingConfig(fd)
}

// generateNetmapConfig creates the network mapper configuration file in the
// default path using the netmapTemplate and returns the path of the created
// file.
func generateNetmapConfig() (string, error) {
	var paths []string
	if os.Getenv("ProgramData") != "" {
		paths = append(paths, filepath.Join(os.Getenv("ProgramData"), "VMware"))
	}

	networks := []NetmapConfig{
		{0, "Bridged", "vmnet0"},
		{1, "HostOnly", "vmnet1"},
		{8, "NAT", "vmnet8"},
	}
	for i := 2; i <= 19; i++ {
		if i != 8 {
			networks = append(networks, NetmapConfig{i, fmt.Sprintf("VMNet%d", i), fmt.Sprintf("vmnet%d", i)})
		}
	}

	sort.Slice(networks, func(i, j int) bool {
		return networks[i].Index < networks[j].Index
	})

	t, err := template.New("netmap").Parse(netmapTemplate)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	if err := t.Execute(&sb, networks); err != nil {
		return "", err
	}
	netmapContent := []byte(sb.String())

	var pathNetmap string
	for _, basePath := range paths {
		path := filepath.Join(basePath, netmapConfFile)
		if err := os.MkdirAll(basePath, 0755); err != nil {
			continue // Skip to the next path on error.
		}
		if err := os.WriteFile(path, netmapContent, 0644); err != nil { //nolint:gosec
			continue // Skip to the next path on error.
		}

		// If the file exists, set pathNetmap and break the loop.
		if _, err := os.Stat(path); err == nil {
			pathNetmap = path
			break // Exit the loop since the file was successfully created.
		}
	}

	if pathNetmap != "" {
		return pathNetmap, nil
	} else {
		return "", fmt.Errorf("no valid path found for generating the network mapper configuration file")
	}
}
