// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package common

import (
	"errors"
	"fmt"
	"html/template"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"github.com/hashicorp/packer-plugin-sdk/multistep"
)

// Template for the network mapper configuration file, 'netmap.conf'.
// This file is used to map network devices to their respective network names.
// This template is used to generate the file if if the default file does not
// exist on the system.
const netmapTemplate = `
# This file is automatically generated.
# Hand-editing this file is not recommended.
network0.name = "Bridged"
network0.device = "vmnet0"
network1.name = "HostOnly"
network1.device = "vmnet1"
{{- range . }}
{{- if gt .Index 1 }}
{{- if lt .Index 8 }}
network{{ .Index }}.name = "VMNet{{ .Index }}"
network{{ .Index }}.device = "vmnet{{ .Index }}"
{{- else if eq .Index 8 }}
network8.name = "NAT"
network8.device = "vmnet8"
{{- else }}
network{{ .Index }}.name = "VMNet{{ .Index }}"
network{{ .Index }}.device = "vmnet{{ .Index }}"
{{- end }}
{{- end }}
{{- end }}
`

// NetmapConfig is a struct that represents a network mapper configuration.
type NetmapConfig struct {
	Index  int
	Name   string
	Device string
}

// Workstation9Driver is a driver that can run VMware Workstation 9
type Workstation9Driver struct {
	VmwareDriver

	AppPath          string
	VdiskManagerPath string
	VmrunPath        string

	// SSHConfig are the SSH settings for the Fusion VM
	SSHConfig *SSHConfig
}

func NewWorkstation9Driver(config *SSHConfig) Driver {
	return &Workstation9Driver{
		SSHConfig: config,
	}
}

func (d *Workstation9Driver) Clone(dst, src string, linked bool, snapshot string) error {
	return errors.New("linked clones are not supported on this version")
}

func (d *Workstation9Driver) CompactDisk(diskPath string) error {
	defragCmd := exec.Command(d.VdiskManagerPath, "-d", diskPath)
	if _, _, err := runAndLog(defragCmd); err != nil {
		return err
	}

	shrinkCmd := exec.Command(d.VdiskManagerPath, "-k", diskPath)
	if _, _, err := runAndLog(shrinkCmd); err != nil {
		return err
	}

	return nil
}

func (d *Workstation9Driver) CreateDisk(output string, size string, adapter_type string, type_id string) error {
	cmd := exec.Command(d.VdiskManagerPath, "-c", "-s", size, "-a", adapter_type, "-t", type_id, output)
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

func (d *Workstation9Driver) CreateSnapshot(vmxPath string, snapshotName string) error {
	cmd := exec.Command(d.VmrunPath, "-T", "ws", "snapshot", vmxPath, snapshotName)
	_, _, err := runAndLog(cmd)
	return err
}

func (d *Workstation9Driver) IsRunning(vmxPath string) (bool, error) {
	vmxPath, err := filepath.Abs(vmxPath)
	if err != nil {
		return false, err
	}

	cmd := exec.Command(d.VmrunPath, "-T", "ws", "list")
	stdout, _, err := runAndLog(cmd)
	if err != nil {
		return false, err
	}

	for _, line := range strings.Split(stdout, "\n") {
		if line == vmxPath {
			return true, nil
		}
	}

	return false, nil
}

func (d *Workstation9Driver) CommHost(state multistep.StateBag) (string, error) {
	return CommHost(d.SSHConfig)(state)
}

func (d *Workstation9Driver) Start(vmxPath string, headless bool) error {
	guiArgument := "gui"
	if headless {
		guiArgument = "nogui"
	}

	cmd := exec.Command(d.VmrunPath, "-T", "ws", "start", vmxPath, guiArgument)
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

func (d *Workstation9Driver) Stop(vmxPath string) error {
	cmd := exec.Command(d.VmrunPath, "-T", "ws", "stop", vmxPath, "hard")
	if _, _, err := runAndLog(cmd); err != nil {
		return err
	}

	return nil
}

func (d *Workstation9Driver) SuppressMessages(vmxPath string) error {
	return nil
}

func (d *Workstation9Driver) Verify() error {
	var err error
	if d.AppPath == "" {
		if d.AppPath, err = workstationFindVMware(); err != nil {
			return err
		}
	}

	if d.VmrunPath == "" {
		if d.VmrunPath, err = workstationFindVmrun(); err != nil {
			return err
		}
	}

	if d.VdiskManagerPath == "" {
		if d.VdiskManagerPath, err = workstationFindVdiskManager(); err != nil {
			return err
		}
	}

	log.Printf("[INFO] VMware app path: %s", d.AppPath)
	log.Printf("[INFO] vmrun path: %s", d.VmrunPath)
	log.Printf("[INFO] vdisk-manager path: %s", d.VdiskManagerPath)

	if _, err := os.Stat(d.AppPath); err != nil {
		return fmt.Errorf("application not found: %s", d.AppPath)
	}

	if _, err := os.Stat(d.VmrunPath); err != nil {
		return fmt.Errorf("'vmrun' not found in path: %s", d.VmrunPath)
	}

	if _, err := os.Stat(d.VdiskManagerPath); err != nil {
		return fmt.Errorf("'vmware-vdiskmanager' not found in path: %s", d.VdiskManagerPath)
	}

	// Check to see if it APPEARS to be licensed.
	if err := workstationCheckLicense(); err != nil {
		return err
	}

	// Assigning the path callbacks to VmwareDriver
	d.VmwareDriver.DhcpLeasesPath = func(device string) string {
		return workstationDhcpLeasesPath(device)
	}

	d.VmwareDriver.DhcpConfPath = func(device string) string {
		return workstationDhcpConfPath(device)
	}

	d.VmwareDriver.VmnetnatConfPath = func(device string) string {
		return workstationVmnetnatConfPath(device)
	}

	d.VmwareDriver.NetworkMapper = func() (NetworkNameMapper, error) {
		// Check if the network mapper configuration file exists.
		mapper, err := checkNetmapConfExists()

		if err == nil {
			return mapper, nil
		}

		// For non-Windows, if neither the default nor alternate configuration
		// paths exist, return an error.
		if err != nil && runtime.GOOS != "windows" {
			return nil, err
		}

		if !errors.Is(err, os.ErrNotExist) {
			return nil, err
		}

		// For Windows, safely generate the network mapper configuration file
		// in the default path.
		pathNetmap, err := generateNetmapConfig()
		if err != nil {
			log.Fatalf("error generating the absent network configuration file: %v", err)
			return nil, err
		}

		// If the file exists, attempt to read the newly generated network
		// mapper configuration file.
		return ReadNetmapConfig(pathNetmap)
	}
	return nil
}

func (d *Workstation9Driver) ToolsIsoPath(flavor string) string {
	return workstationToolsIsoPath(flavor)
}

func (d *Workstation9Driver) ToolsInstall() error {
	return nil
}

func (d *Workstation9Driver) GetVmwareDriver() VmwareDriver {
	return d.VmwareDriver
}

// checkNetmapConfExists checks if the network mapper configuration file exists.
// If not, if attempts to generate the file using generateNetmapConfig.
func checkNetmapConfExists() (NetworkNameMapper, error) {
	pathNetmap := workstationNetmapConfPath()

	// Check if the default network mapper configuration file exists.
	_, err := os.Stat(pathNetmap)

	if err == nil {
		// If the default network mapper configuration file exists, read the configuration.
		log.Printf("[INFO]Located the network mapper configuration file: %s", pathNetmap)
		return ReadNetmapConfig(pathNetmap)
	}

	if !os.IsNotExist(err) {
		return nil, fmt.Errorf("error determining network mappings from files %w", err)
	}

	log.Printf("A network mapper configuration file does not exist in the default path: %s", pathNetmap)

	// The file does not exist, check the alternate configuration path.
	libpath, _ := workstationVMwareRoot()
	pathNetworking := filepath.Join(libpath, "networking")
	log.Printf("[INFO] Checking alternate path for network mapper configuration file: %s", pathNetworking)
	_, err = os.Stat(pathNetworking)

	// If there is an error, wrap return it.
	// The caller can check if it is a ErrNotExist and act accordingly.
	if err != nil {
		return nil, fmt.Errorf("error determining network mappings from files %w", err)
	}

	// Alternate networking configuration path exists. Using this path.
	log.Printf("[INFO] Located the network mapper configuration file: %s", pathNetworking)
	fd, err := os.Open(pathNetworking)
	if err != nil {
		return nil, err
	}

	defer fd.Close()

	// Pass the handle to the networking configuration parser.
	return ReadNetworkingConfig(fd)
}

// generateNetmapConfig creates the network mapper configuration file in the
// default path using the netmapTemplate and returns the path of the created
// file.
func generateNetmapConfig() (string, error) {
	var paths []string
	if os.Getenv("ProgramData") != "" {
		paths = append(paths, filepath.Join(os.Getenv("ProgramData"), "VMware"))
	}

	networks := []NetmapConfig{
		{0, "Bridged", "vmnet0"},
		{1, "HostOnly", "vmnet1"},
		{8, "NAT", "vmnet8"},
	}
	for i := 2; i <= 19; i++ {
		if i != 8 {
			networks = append(networks, NetmapConfig{i, fmt.Sprintf("VMNet%d", i), fmt.Sprintf("vmnet%d", i)})
		}
	}

	sort.Slice(networks, func(i, j int) bool {
		return networks[i].Index < networks[j].Index
	})

	t, err := template.New("netmap").Parse(netmapTemplate)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	if err := t.Execute(&sb, networks); err != nil {
		return "", err
	}
	netmapContent := []byte(sb.String())

	var pathNetmap string
	for _, basePath := range paths {
		path := filepath.Join(basePath, "netmap.conf")
		if err := os.MkdirAll(basePath, 0755); err != nil {
			continue // Skip to the next path on error.
		}
		if err := os.WriteFile(path, netmapContent, 0644); err != nil {
			continue // Skip to the next path on error.
		}

		// If the file exists, set pathNetmap and break the loop.
		if _, err := os.Stat(path); err == nil {
			pathNetmap = path
			break // Exit the loop since the file was successfully created.
		}
	}

	if pathNetmap != "" {
		return pathNetmap, nil
	} else {
		return "", fmt.Errorf("no valid path found for generating the network mapper configuration file")
	}
}
